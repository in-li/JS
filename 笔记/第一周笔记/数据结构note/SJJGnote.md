# 数据结构知识点备考
+  一个带权的无向连通图的最小生成树  有一棵或多棵
+ 最小生成树指的是  连通图的所有生成树中权值之和最小的生成树
+ n个顶点的强连通图中至少含有 n条有向边
+ 一个具有k条边的无向图,采用邻接表存储,则共需要 2k 个邻接结点
+ 一个有n个顶点的无向图最多有 n(n-1)/2 条边
+ 图的邻接矩阵而言, 第i行的非零元素个数与第i列的非零元素个数一定相等
+ 在一个具有n个顶点的有向图中,所以顶点的出度之和为dout,则所有顶点的入度之和 dout
+ 如果从无向图的任一顶点出发进行一次深度优先搜索即可访问所有顶点,则该图一定是 连通图
+ 若m个顶点的无向图采用临接矩阵存储方法,则该邻接矩阵是一个 对称矩阵
+ 采用邻接表存储的图的深度优先遍历算法类似于二叉树的 先序遍历
+ 采用邻接表存储的图的广度优先遍历算法类似于二叉树的 按层遍历
+ 具有n 个结点的连通图至少有 N-1 条边
+ 哈夫曼树是访问叶结点的带权路径长度 最短 的二叉树
+ 树最适合用来表示  元素之间具有分支层次关系的数据
+ 若由树转化得到的二叉树是非空的二叉树,则二叉树形状是 各结点只有一个儿子的二叉树
+ 设森林F对应的二叉树为B,它有m个结点,B的根为p,p的右子树的结点个数为n,森林F中第一棵树的结点的个数是 m-n
+ 二叉树中最多只有两棵子树,并且有左,右之分
+ 二叉树的定义,具有3个结点的二叉树形态有 5 种
+ 以二叉链表作为二叉树的储存结构,在具有n个结点的二叉链表中(n>0),空链域的个数为 n+1 
+ 具有4个结点的二叉树的形状有 14 种
+ 具有k层的二叉树只有度为0和度为2的结点,则该二叉树上最多有  2^k-1  结点
+ 将一棵有100个结点的完全二叉树从上到下、从左到右依次对结点进行编号,根结点的编号为1,则编号为49的结点的左孩子的编号为 98
+ 将一棵有50个结点的完全二叉树按层编号,则对编号为25的结点x,该结点  有左孩子,无右孩子
+ 已知一棵二叉树的先序遍历序列为EFHIGJK,中序遍历序列为HFIEJGK,则该二叉树根的右子树的根是 G
+ 某二叉树的先序遍历序列和后序遍历序列正好相反,则该二叉树一定是 没有度为2的结点
+ 设X与Y是二叉树上的两个结点,X要在中序遍历中位于Y之前,则一定有 X在Y的上方
+ 除根结点外,树上每个结点 可有任意多个孩子、一个双亲
+ 下列数据结构中,是非线性结构的是 树
+  树结构中,前驱结点与后继结点之间存在 一对多  关系
+ 深度为K的满二叉树共有 2*(k-1) 个结点
+ 树的度规定为 结点度之和
+ 一棵二叉树的先序遍历次序为ABDGECFH,中序遍历次序为DGBEAFHC,则其后序遍历次序为 GDEBHFCA
+ 下列有关树的概念错误的是 一棵树的度为树中各个结点的度数之和
+ 在二叉树结点的先序序列、中序序列和后序序列中,所有叶子结点的先后顺序 完全相同
+ 对一个满二叉树,m个叶子,n个结点,深度为h,则 n = 2^h-1 
+ 若一棵二叉树具有10个度为2的结点,5个度为1的结点,则度为0的结点的个数是 11
+ 具有10个叶子结点的二叉树中有 9 个度为2的结点
+ 若串s1="hello",s2='world',那么执行 strlen(strcat(s1,s2))后的结果是 10
+ 串的长度是 串中所含字符的数目
+ 设有串S1=”STUDENT” 和串S2=”TEACH” ,函数add(x,y)实现将y串连接到x串的后面,函数subs(s,i,j)将得到从串s中第i个字符开始的j个字符组成的子串,函数len(s)返回串s的长度,则add(subs(S1,3,len(S2)),subs(S2,len(S1)-4,3))的结果是 UDENTACH
+ 若串S=‘software’,其子串的数目是 37
+ 串是一种特殊的线性表,其特殊性体现在 数据元素是一个字符
+ 设有两个串p和q,求q在p中首次出现的位置的运算称为 模式匹配
+ 空串与空白串 不相同
+ 从未排序子表中依次取出元素放入到已排序子表的正确位置上的方法是 简单插入排序
+ 从未排序序列中挑选元素，将其放在已排序序列的一端，这种排序方法称为 选择排序
+ 在下列排序方法中，不稳定的排序方法是 直接选择排序
+ 堆排序是一种 选择 排序
+ 堆的形状是一棵 完全二叉树
+ 对以下几个关键字进行快速排序，以第一个元素为轴，一次划分效果不好的是 1，2，3，4，5，6，7
+ 快速排序在 被排序的数据完全无序 情况下最易发挥其长处
+ 快速排序算法在 线性表元素个数为偶数 情况下效率最低
+ 快速排序是对冒泡排序的一种改进
+ 对二叉排序树，使用 中序遍历 的遍历方式，可以获得对结点序列关键字的排序
+ 排序方法中，从未排序序列中依次取出元素与已排序序列中的元素进行比较，将其放入已排序序列的正确位置上的方法，称为 入排序
+ 在所有的排序方法中，关键字比较的次数与记录的初始排列次序无关的是 直接选择排序
+ 堆是一种有用的数据结构。下列关键码序 16,31,23,94,53,72 是一个堆
+ 堆排序是一种 选择 排序
+ 插入 在链表中进行操作比在顺序表中进行操作效率高
+ 二叉排序树为 具有最小深度  形态时，查找效率最高
+ 在散列函数H（k）=k%m中，一般来讲，m应该取 素数
+ 对于长度为18的顺序存储的有序表，若采用折半查找，则查找第15个元素的比较次数为 4
+ 对线性表进行二分查找时，要求线性表必须 以顺序方式存储，且结点按关键字有序排序
+ 散列表的地址区间为0~16，散列函数为h(k)=k%17，采用线性探查法解决冲突，将关键字序列26，25，72，38，1，18，59依次存储到散列表中。元素59存放在散列表的地址为 10
+ 设有序表的关键字序列为{1，4，6，10，18，35，42，53，67，71，78，84，92，99}，当用二分查找法查找关键值为84的节点时，经 4 次比较后查找成功
+ 采用折半检索方式对一个有15个元素的有序线性表检索，元素的平均查找长度为 49/15
+ 顺序查找法适合存储结构为 顺序存储或链接存储 的线性表
+ 对线性表进行折半查找时，要求线性表必须 以顺序方式存储，且结点按关键字有序排列
+ 采用折半查找法查找长度为n的线性表时，每个元素的平均查找长度为 O(log 2^n)
+ 有一个有序表为｛1，3，9，12，32，41，45，62，75，77，82，95，100｝，当折半查找值为82的结点时， 4 次比较后查找成功
+ 查找效率最高的二叉排序树是 平衡二叉树
+ 下面关于B树和B+树的叙述中，不正确的结论是B树和B+树都能有效的支持顺序查找
+  一个队列的入队序列是1、2、3、4,则队列的输出顺序为 1、2、3、4
+ 栈和队列的共同特点是 只允许在端点处插入和删除元素
+ 环队列q当前队列中元素的个数为 (rear–front + m)%m
+ 在循环队列中,若front与rear 分别表示对头元素和队尾元素的位置,则判断循环队列空的条件是 front==rear
+ 设数组Data[n]作为循环队列Q的存储空间,front作为队头指针,rear作为队尾指针,则执行入队操作的语句为 Q->rear=(Q->rear+1)%n
+ 设栈S和队列Q的初始状态为空,元素e1、e2、e3、e4、e5和e6依次通过栈S,一个元素出栈后即进入队列Q,若6个元素出队的顺序是e2、e4、e3、e6、e5、e1,则栈S的容量至少应是 3
+ 队列的特性描述是 FIFO
+ 从队列中删除第i个元素 不是队列的基本运算
+ 允许对队列进行的操作有 删除队头元素
+ 队列的“先进先出”特性是指 每次从队列中删除的总是最早插入的元素
+ 若用一个大小为6的数值来实现循环队列,且当前rear和front的值分别为0和3,当从队列中删除一个元素,再加入两个元素后,rear和front的值分别为 2和4
+ 用不带头结点的单链表存储队列,其头指针指向队头结点,尾指针指向队尾结点,则在进行出队操作时 队头、队尾指针都可能要修改
+ 设某个初始为空的容纳int型数据的非循环队列进行了如下操作(每一步均未发生溢出):入队(1)、入队(3)、出队( )、入队(6)、入队(1)、出队( )、入队(3)、入队(8)后,该队列中从队尾到队首的元素依次为 8316
+ 假设n个元素按照一定的顺序进栈和出栈,已知第一个出栈的元素是最后一个进栈的元素, 第i个出栈的元素是第n-i+1个入栈的元素
+ 栈的插入和删除操作在 栈顶
+ 判定一个顺序栈st(最多元素为MaxSize)为空的条件是 st->top == -1
+ 判定一个顺序栈st(最多元素为MaxSize)为满的条件是 st->top == MaxSize
+ 若让元素1,2,3依次进栈,则出栈次序不可能出现 3,1,2 种情况
+ 链栈与顺序栈相比,比较明显的优点是 不会出现上溢的情况
+ 设某个初始为空的容纳int型数据的堆栈进行了如下操作(每一步均未发生溢出):push(1)、push(3)、pop()、push(6)、push(1)、pop()、push(3)、push(8)后,该堆栈中从栈顶到栈底的元素依次为 8361
+ 一个栈的进栈序列是a,b,c,d,e,则栈的不可能的输出序列是 dceab
+ 向一个栈顶指针为h的带头结点的链栈中插入指针s所指的结点时,应执行 s->next=h->next ;h->next=s  操作
+ 若已知一个栈的进栈序列是1,2,3,,n,其输出序列为p1,p2,p3,…,pn,若p1=n,则pi为 n-i+1
+ 设计一个判别表达式中左、右括号是否配对出现的算法,采用 栈 数据结构最佳
+ 和顺序栈相比,链栈有一个比较明显的优势是 通常不会出现栈满的情况
+ 算法分析的两个主要方面是 空间复杂度和时间复杂度
+ 算法分析的目的是 分析算法的效率以求改进
+ 下列算法的时间复杂度是 O(n)
+ 在存储数据时,通常不仅要存储各数据元素的值,而且还要存储 数据元素之间的关系
+ 在数据结构中,与所使用的计算机无关的是数据的 逻辑 结构
+ 通常要求同一逻辑结构中的所有数据元素具有相同的特性,这意味着 B不仅数据元素所包含的数据项的个数要相同,而且对应的数据项的类型要一致
+ 在数据结构中,从逻辑上可以把数据结构分成 线性结构和非线性结构
+ 在决定选取何种存储结构时,一般不考虑  各结点的值如何
+ 一些表面上很不相同的数据可以有相同的逻辑结构
+ 在存储数据时,通常不仅要存储各数据元素的值,而且还要存储 数据元素之间的关系
+ 通常要求同一逻辑结构中的所有数据元素具有相同的特性,这意味着 不仅数据元素所包含的数据项的个数要相同,而且对应的数据项的类型要一致
+ 数据结构不是一门研究数值计算的学科,它主要研究计算机中的 数据元素 以及它们之间的关系和运算等方面
+ 与数据的存储结构无关的术语是 队列
+ 数据结构在计算机内存中的表示是指 数据的存储结构
+ 与单向链表相比,双向链表的优点是  更灵活地访问相邻结点
+ 在一个单链表中,已知q所指结点是p所指结点的前驱结点,若在q和p之间插入一个结点s,则执行 q->next=s;s->next=p
+  在单链表中,若p所指结点不是最后结点,在p之后插入s所指结点,则执行 p->next=s->next; s->next=p
+ 在链接式队列中删除结点时,执行的操作为 front = front->next
+ 线性表必须先 元素按关键值大小排列 后,才能对线性表进行折半检索
+ 线性表采用链式存储时,结点的地址是 必须是连续的
+ 表采用链式存储时,其地址 连续不连续都可以
+ 链表不具备的特点是 可直接访问任意元素
+ 线性表若采用链表存储结构时,要求内存中可用存储单元的地址 连续不连续都可以
+ 在单链表中,增加头结点的目的是为了 方便运算的实现
+ 线性表(a1,a2, … ,an)以链式方式存储,访问第i位置元素的时间复杂度为  O(n)
+ 单链表中,增加一个头结点的目的是为了 方面运算的实现
+ 在单链表指针为p的结点之后插入指针为s的结点,正确的操作是 s->next=p->next ;p->next=s
+ 非空的循环单链表head的尾结点(由p所指向)满足 p->next ==head
+ 在循环双向链表的p所指的结点之前插入s所指结点的操作是 s->next = p;s->prior = p->prior;p->prior->next = s;p->prior = s
+ 在一个具有n个结点的有序单链表中插入一个新结点并仍然保持有序的时间复杂度 O(n)
+ 在一个长度为n(n>1)的单链表上,设有头和尾两个指针,执行 删除单链表中的最后一个元素 操作与链表的长度有关 
+ 与单链表相比,双向链表的优点之一是 顺序访问相邻结点更灵活
+ 对于只在表的首、尾两端进行插入操作的线性表,宜采用的存储结构为 用尾指针表示的循环单链表
+ 在单向链表的第i个结点前插入新结点时,需预先保留的结点指针是 指向i结点的指针
+ 如果对线性表的操作只有两种,即删除第一个元素,在最后一个元素的后面插入新元素,则最好使用 只有表尾指针没有表头指针的循环单链表
+ 若某表最常用的操作是在最后一个结点之后插入一个结点或删除最后一个结点,则采用 带头结点的双循环链表  存储方式最节省运算时间
+ 链表不具备的特点是 可随机访问任一结点
+ 不带头结点的单链表head为空的判定条件是 head == NULL
+ 一个长度为n的顺序表中,在第i个元素前插入一个新元素时,需要向后移动 n-i+1 元素
+ 线性表中的元素之间是线性关系
+ 在表长为n的顺序表上做插入运算,平均要移动的结点数为 n/2
+ 线性表的顺序存储结构是一种 顺序 存取的存储结构
+ 线性表的顺序存储结构是一种  随机存取的存储结构
+ 需要分配较大空间,插入和删除不需要移动元素的线性表,其存储结构是  静态链表
+ 如果最常用的操作是取第i个结点及其前驱,则采用 顺序表 存储方式最节省时间
+ 用数组表示线性表的优点是 便于随机存取
+ 顺序存储结构的优点是 储密度大
+ 线性表是具有n个 数据元素 的有限序列
+ 在n个结点的线性表的数组实现中,算法的时间复杂度是O(1)的操作是 访问第i(1<=i<=n)个结点和求第i个结点的直接前驱(1<i<=n)
+ 若长度为n的线性表采用顺序存储结构,在其第i个位置插入一个新元素的算法的时间复杂度为 O(n)
+ 对于顺序存储的线性表,访问结点和增加、删除结点的时间复杂度为 O(1) O(n)